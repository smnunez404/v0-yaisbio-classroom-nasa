import type { Mission, Paper, DifficultyLevel, Language } from "@/types"

const GEMINI_API_KEY = process.env.GEMINI_API_KEY || "AIzaSyDxJ0Hk9OTVvcouoBmCL5ry9pfpyCAPvZ4"
const TTS_MODEL = "gemini-2.5-pro-preview-tts"
const MAX_CONTEXT_TOKENS = 32000

interface AudioChunk {
  data: Buffer
  mimeType: string
}

function estimateTokens(text: string): number {
  return Math.ceil(text.length / 4)
}

export async function generateMissionPodcast(
  mission: Mission,
  paper: Paper,
  level: DifficultyLevel,
  language: Language,
): Promise<AudioChunk[]> {
  const levelDescriptions = {
    beginner: language === "es" ? "principiante (12-15 años)" : "beginner (ages 12-15)",
    intermediate: language === "es" ? "intermedio (16-18 años)" : "intermediate (ages 16-18)",
    advanced: language === "es" ? "avanzado (universitario)" : "advanced (university level)",
  }

  const script =
    language === "es"
      ? `Lee en voz alta con un tono cálido y entusiasta, como un podcast educativo:

Gemma: ¡Bienvenidos a YaisBio Classroom! Hoy comenzamos una misión fascinante sobre ${mission.titleEs}.

Mauricio: Esta misión está basada en investigación real de la NASA. El paper científico se titula: "${paper.titleEs}".

Gemma: Vas a explorar conceptos como ${mission.conceptsEs.slice(0, 3).join(", ")}. ¿Estás listo para esta aventura espacial?

Mauricio: Imagina que eres un científico en la Estación Espacial Internacional. Tu misión: ${mission.descriptionEs}

Gemma: Esta es una investigación de nivel ${levelDescriptions[level]}, diseñada especialmente para ti. ¡Comencemos!`
      : `Read aloud in a warm, enthusiastic tone, like an educational podcast:

Gemma: Welcome to YaisBio Classroom! Today we're starting a fascinating mission about ${mission.title}.

Mauricio: This mission is based on real NASA research. The scientific paper is titled: "${paper.title}".

Gemma: You'll explore concepts like ${mission.concepts.slice(0, 3).join(", ")}. Are you ready for this space adventure?

Mauricio: Imagine you're a scientist on the International Space Station. Your mission: ${mission.description}

Gemma: This is a ${levelDescriptions[level]} investigation, designed especially for you. Let's begin!`

  const estimatedTokens = estimateTokens(script)
  if (estimatedTokens > MAX_CONTEXT_TOKENS) {
    throw new Error(`Script exceeds token limit: ${estimatedTokens} tokens (max: ${MAX_CONTEXT_TOKENS})`)
  }

  console.log(`[v0] Generating TTS with ${estimatedTokens} estimated tokens`)

  const requestBody = {
    contents: [
      {
        role: "user",
        parts: [
          {
            text: script,
          },
        ],
      },
    ],
    generationConfig: {
      responseModalities: ["audio"],
      temperature: 1,
      speech_config: {
        multi_speaker_voice_config: {
          speaker_voice_configs: [
            {
              speaker: "Gemma",
              voice_config: {
                prebuilt_voice_config: {
                  voice_name: "Callirrhoe",
                },
              },
            },
            {
              speaker: "Mauricio",
              voice_config: {
                prebuilt_voice_config: {
                  voice_name: "Algenib",
                },
              },
            },
          ],
        },
      },
    },
  }

  const url = `https://generativelanguage.googleapis.com/v1beta/models/${TTS_MODEL}:generateContent?key=${GEMINI_API_KEY}`

  console.log("[v0] Calling Gemini API:", url.replace(GEMINI_API_KEY, "***"))

  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(requestBody),
  })

  if (!response.ok) {
    const errorText = await response.text()
    console.error("[v0] Gemini API error:", response.status, errorText)
    throw new Error(`Gemini API error (${response.status}): ${errorText}`)
  }

  const result = await response.json()
  console.log("[v0] Gemini API response received")

  const audioChunks: AudioChunk[] = []

  if (result.candidates && result.candidates.length > 0) {
    const candidate = result.candidates[0]
    if (candidate.content && candidate.content.parts) {
      for (const part of candidate.content.parts) {
        if (part.inlineData && part.inlineData.data) {
          audioChunks.push({
            data: Buffer.from(part.inlineData.data, "base64"),
            mimeType: part.inlineData.mimeType || "audio/wav",
          })
        }
      }
    }
  }

  console.log(`[v0] Extracted ${audioChunks.length} audio chunks`)

  if (audioChunks.length === 0) {
    console.error("[v0] No audio data in response:", JSON.stringify(result, null, 2))
    throw new Error("No audio data generated by Gemini API")
  }

  return audioChunks
}

export function convertToWav(audioData: Buffer, mimeType: string): Buffer {
  const parameters = parseAudioMimeType(mimeType)
  const bitsPerSample = parameters.bitsPerSample
  const sampleRate = parameters.rate
  const numChannels = 1
  const dataSize = audioData.length
  const bytesPerSample = bitsPerSample / 8
  const blockAlign = numChannels * bytesPerSample
  const byteRate = sampleRate * blockAlign
  const chunkSize = 36 + dataSize

  const header = Buffer.alloc(44)

  header.write("RIFF", 0)
  header.writeUInt32LE(chunkSize, 4)
  header.write("WAVE", 8)
  header.write("fmt ", 12)
  header.writeUInt32LE(16, 16)
  header.writeUInt16LE(1, 20)
  header.writeUInt16LE(numChannels, 22)
  header.writeUInt32LE(sampleRate, 24)
  header.writeUInt32LE(byteRate, 28)
  header.writeUInt16LE(blockAlign, 32)
  header.writeUInt16LE(bitsPerSample, 34)
  header.write("data", 36)
  header.writeUInt32LE(dataSize, 40)

  return Buffer.concat([header, audioData])
}

function parseAudioMimeType(mimeType: string): { bitsPerSample: number; rate: number } {
  let bitsPerSample = 16
  let rate = 24000

  const parts = mimeType.split(";")
  for (const param of parts) {
    const trimmed = param.trim()
    if (trimmed.toLowerCase().startsWith("rate=")) {
      const rateStr = trimmed.split("=")[1]
      rate = Number.parseInt(rateStr) || 24000
    } else if (trimmed.startsWith("audio/L")) {
      const bits = trimmed.split("L")[1]
      bitsPerSample = Number.parseInt(bits) || 16
    }
  }

  return { bitsPerSample, rate }
}
